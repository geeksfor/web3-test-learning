# 2026-02-03 - D8：ERC721 测试框架（mint / ownerOf / balanceOf）+ fuzz + invariant

tags: [foundry, forge, solidity, testing, erc721, fuzz, invariant]


## 背景 / 目标
今天的目标是用 **Foundry** 搭一个最小可复用的 **ERC721 测试框架**，先把 NFT 的三条核心链路跑通，并补上两类“自动找 bug”的能力：
1. **基础功能**：`mint / ownerOf / balanceOf`
2. **事件校验**：`Transfer(address(0), to, tokenId)`
3. **fuzz**：随机 `tokenId`（排除 `to=0`）后，`ownerOf(tokenId)` 必须等于 `to`
4. **invariant（状态机风格）**：随机多步调用 handler，保证 `balanceOf(target) == 成功 mint 次数`

---

## 今日完成清单
- [x] 写最小 ERC721 合约（只包含 `mint/ownerOf/balanceOf` + 自定义错误 + Transfer 事件）
- [x] 写单元测试：成功路径 + 异常路径（ZeroAddress / TokenAlreadyMinted / NonexistentToken）
- [x] 增加事件断言：`vm.expectEmit` + `emit Transfer(...)`
- [x] 增加 fuzz：`vm.assume(to != address(0))`
- [x] 增加 invariant：`StdInvariant + targetContract(handler)`，并理解 `invariant_` 命名规则

---

## 一、最小 ERC721 实现（src/SimpleERC721.sol）
> 目的：只实现今天要测的三个函数，保持最小化，便于理解测试框架。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract SimpleERC721 {
    // ============ errors ============
    error ZeroAddress();
    error TokenAlreadyMinted(uint256 tokenId);
    error NonexistentToken(uint256 tokenId);

    // ============ events ============
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    // ============ storage ============
    mapping(uint256 => address) private _ownerOf;
    mapping(address => uint256) private _balanceOf;

    // ============ views ============
    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _ownerOf[tokenId];
        if (owner == address(0)) revert NonexistentToken(tokenId);
        return owner;
    }

    function balanceOf(address owner) public view returns (uint256) {
        if (owner == address(0)) revert ZeroAddress();
        return _balanceOf[owner];
    }

    // ============ mint ============
    function mint(address to, uint256 tokenId) external {
        if (to == address(0)) revert ZeroAddress();
        if (_ownerOf[tokenId] != address(0)) revert TokenAlreadyMinted(tokenId);

        _ownerOf[tokenId] = to;
        unchecked {
            _balanceOf[to] += 1;
        }

        emit Transfer(address(0), to, tokenId);
    }
}
```

---

## 二、单元测试（test/SimpleERC721.t.sol）
### 2.1 成功路径：mint 后 ownerOf/balanceOf 正确 + Transfer 事件正确
```solidity
function test_mint_success_updatesOwnerAndBalance_andEmitsTransfer() public {
    uint256 tokenId = 1;

    // expectEmit 的 4 个 bool：topic1/topic2/topic3/data（不是“参数个数”）
    // Transfer 的三个参数都 indexed，因此会进 topic1~topic3；data 为空
    vm.expectEmit(true, true, true, false);
    emit SimpleERC721.Transfer(address(0), alice, tokenId);

    nft.mint(alice, tokenId);

    assertEq(nft.ownerOf(tokenId), alice);
    assertEq(nft.balanceOf(alice), 1);
}
```

### 2.2 异常路径
```solidity
function test_mint_reverts_ifToIsZeroAddress() public {
    vm.expectRevert(SimpleERC721.ZeroAddress.selector);
    nft.mint(address(0), 1);
}

function test_mint_reverts_ifTokenAlreadyMinted() public {
    nft.mint(alice, 1);

    vm.expectRevert(abi.encodeWithSelector(SimpleERC721.TokenAlreadyMinted.selector, 1));
    nft.mint(bob, 1);
}

function test_ownerOf_reverts_ifNonexistentToken() public {
    vm.expectRevert(abi.encodeWithSelector(SimpleERC721.NonexistentToken.selector, 999));
    nft.ownerOf(999);
}

function test_balanceOf_reverts_ifOwnerIsZeroAddress() public {
    vm.expectRevert(SimpleERC721.ZeroAddress.selector);
    nft.balanceOf(address(0));
}
```

---

## 三、fuzz：随机 tokenId，mint 后 ownerOf(tokenId) 必须等于 to
> 关键点：排除 `to=address(0)`，否则 mint 会 revert，fuzz 会把它当失败（除非你预期它 revert）。

```solidity
function testFuzz_mint_ownerOf_isTo(address to, uint256 tokenId) public {
    vm.assume(to != address(0));

    // 可选：限制 tokenId 范围提升样本密度
    // tokenId = bound(tokenId, 1, 1_000_000);

    nft.mint(to, tokenId);
    assertEq(nft.ownerOf(tokenId), to);
}
```

---

## 四、invariant（状态机风格）：随机多步 + 随机 tokenId
### 4.1 为什么需要 handler + targetContract？
- **handler**：把“可被随机调用的动作”集中在一个合约里（mintRandom / transfer / approve ...）
- `targetContract(address(handler))`：告诉 invariant 引擎“随机调用就只在 handler 上选方法”
- `invariant_` 前缀：Foundry 用它识别不变量函数（不是 `test_`）

### 4.2 代码（test/SimpleERC721InvariantRandom.t.sol）
```solidity
import "forge-std/Test.sol";
import "forge-std/StdInvariant.sol";
import "../src/SimpleERC721.sol";

contract ERC721MintRandomHandler is Test {
    SimpleERC721 public nft;
    address public target;

    // ghost state：记录成功 mint 过的 tokenId
    mapping(uint256 => bool) public minted;
    uint256 public mintedCount;

    constructor(SimpleERC721 _nft, address _target) {
        nft = _nft;
        target = _target;
    }

    // fuzzer 会随机多次调用，并随机给 tokenId
    function mintRandom(uint256 tokenId) external {
        tokenId = bound(tokenId, 1, 1_000_000);

        // 避免重复 tokenId 导致 revert，保证状态能持续推进
        vm.assume(!minted[tokenId]);

        nft.mint(target, tokenId);

        minted[tokenId] = true;
        mintedCount++;
    }
}

contract SimpleERC721InvariantRandomTest is StdInvariant, Test {
    SimpleERC721 nft;
    ERC721MintRandomHandler handler;

    address constant ALICE = address(0xA11CE);

    function setUp() public {
        nft = new SimpleERC721();
        handler = new ERC721MintRandomHandler(nft, ALICE);

        targetContract(address(handler));

        // 可选：让每轮随机“走更多步”
        // vm.setInvariantRuns(200);
        // vm.setInvariantDepth(50);
    }

    // invariant：合约余额必须等于 handler 记录的成功 mint 次数
    function invariant_balanceEqualsSuccessfulMints() public view {
        assertEq(nft.balanceOf(ALICE), handler.mintedCount());
    }

    // 可选：如果 handler 说 tokenId 已 mint，则 ownerOf(tokenId) 必须是 ALICE
    function invariant_mintedTokenOwnerIsAlice(uint256 tokenId) public view {
        tokenId = bound(tokenId, 1, 1_000_000);
        if (handler.minted(tokenId)) {
            assertEq(nft.ownerOf(tokenId), ALICE);
        }
    }
}
```

---

## 五、运行命令（普通测试 & invariant 都一样用 forge test）
### 5.1 跑全部
```bash
forge test -vvv
```

### 5.2 只跑某个文件
```bash
forge test --match-path test/SimpleERC721.t.sol -vvv
forge test --match-path test/SimpleERC721InvariantRandom.t.sol -vvv
```

### 5.3 只跑某个函数
```bash
forge test --match-test testFuzz_mint_ownerOf_isTo -vvv
forge test --match-test invariant_balanceEqualsSuccessfulMints -vvv
```

### 5.4 调整 invariant 强度
```bash
forge test --match-path test/SimpleERC721InvariantRandom.t.sol \
  --invariant-runs 200 --invariant-depth 50 -vvv
```

### 5.5 固定 seed 便于复现
```bash
forge test --match-path test/SimpleERC721InvariantRandom.t.sol --seed 12345 -vvv
```

---

## 六、关键知识点总结
### 6.1 ERC20 vs ERC721（写测试时的直观差别）
- ERC20：`Transfer(from,to,amount)`（amount 是数量）
- ERC721：`Transfer(from,to,tokenId)`（tokenId 是唯一标识）
- ERC721 的 `ownerOf(tokenId)`：不存在 token 必须 revert
- ERC721 的 `balanceOf(address(0))`：必须 revert

### 6.2 vm.expectEmit 的 4 个 bool
`vm.expectEmit(a,b,c,d)` 固定含义是：
- a：检查 topic1（第 1 个 indexed 参数）
- b：检查 topic2（第 2 个 indexed 参数）
- c：检查 topic3（第 3 个 indexed 参数）
- d：检查 data（非 indexed 的 ABI 编码部分）

即使 event 全部 indexed，data 也存在，只是空；写 `false` 更直观（只校验 topics）。

### 6.3 vm.expectRevert(selector) vs abi.encodeWithSelector(...)
- **无参数 error**（如 `ZeroAddress()`）：用 `.selector` 足够精确
- **有参数 error**（如 `TokenAlreadyMinted(tokenId)`）：用 `abi.encodeWithSelector` 才能把参数也断言住

### 6.4 invariant 为什么不用 test_ 前缀？
- Foundry 通过 `invariant_` 识别不变量函数
- `test_` 只会跑普通测试，不会驱动 handler 的随机多步状态演化

---

## 七、分支命名建议
推荐：`d8-erc721-mint-owner-balance`  
如果包含事件校验：`d8-erc721-mint-owner-balance-transfer`

---

## 八、下一步（D9/D10 建议）
要真正体现“混合序列状态机”（mint/approve/transferFrom/safeTransferFrom），建议：
1. D9：补 `approve + transferFrom` 最小实现（含清授权）
2. D10：补 `safeTransferFrom`（接收合约 `onERC721Received`）
3. 扩展 handler：随机 mint/approve/transferFrom，多地址交互
4. 写更强 invariant：`balanceOf(owner) == ownedSetSize(owner)`、所有 tokenId 的 ownerOf 不为 0 等

